	Interface from JDK 1.8V
	------------------------
	What is the limitation of abstract method in project maintenance :
	-------------------------------------------------------------
	Java 8 fetaures are introduced in java from March 2014.
	
	intreface from JDK 1.8V  [Java 8 = March 2014]
	----------------------------------------------
	Limitation of abstract method    
	           OR
	Maintenance problem with interface in an Industry upto JDK 1.7
	
	The major maintenance problem with interface is, if we add any new abstract method at the
	later stage of development inside an existing interface then all the implementer classes 
	have to override that abstract method otherwise the  implementer class will become as an
	abstract class so it is one kind of boundation.
	
	We need to provide implementation for all the abstract methods available inside an interface whether it is required or not?
	
	To avoid this maintenance problem java software people introduced default method inside an interface.
	-------------------------------------------------------------
	What is default method :
	-------------------------
	It is possible to write default method (default keyword + method body) inside an interface from JDK 1.8V.
	
	A default method we can declare only inside an interface but not in a class.
	
	A default method must be declared with default keyword and contains method body.
	
	By default access modifier of a default method is public.
	
	A default method cannot be marked as abstract, final or static.
	
	A default method may be overridden by a class that implements the
	interface.[Without any boundation]
	
	It is mainly used to provide "DEFAULT IMPLEMENTATION"
	
	------------------------------------------------------------------
	4 files :
	---------
	Vehicle.java(I)
	-------------
	package com.ravi.java8;
	
	public interface Vehicle
	{    
	   void run();
	   void horn();
	   
	   default void digitalMeter()  //java 8
	   {
	      System.out.println("Digital Meter Facility is coming soon!!!");
	   }
	}
	
	Car.java
	----------
	package com.ravi.java8;
	
	public class Car implements Vehicle
	{
	    @Override
	    public void run()
	    {
	        System.out.println("Car is Running");        
	    }
	
	    @Override
	    public void horn()
	    {
	        System.out.println("Car has Horn");        
	    }
	   
	    @Override
	    public void digitalMeter()  //java 8
	    {
	      System.out.println("Car has Digital Meter Facility");      
	    }
	   
	}
	
	Bike.java
	---------
	package com.ravi.java8;
	
	public class Bike implements Vehicle
	{
	   
	    @Override
	    public void run()
	    {
	        System.out.println("Bike is Running");        
	    }
	   
	    @Override
	    public void horn()
	    {
	        System.out.println("Bike has Horn");        
	    }
	}
	
	DefaultMethod.java
	------------------
	package com.ravi.java8;
	
	public class DefaultMethod
	{
	    public static void main(String[] args)
	    {
	       
	        Vehicle v = null;
	       
	        v = new Car(); v.run(); v.horn(); v.digitalMeter();
	        v = new Bike(); v.run(); v.horn();v.digitalMeter();
	    }
	
	}
	
	Priority of deafult and concrete method :
	-----------------------------------------
	While working with class and interface, default method is having low priority than concrete method, 
	In the same way class is more powerful than interface.
	
	interface A
	{
	}
	class B
	{
	}
	
	class C extends B implements A  {}  //Valid
	
	class C implements A extends B {} //Invalid
	-------------------------------------------------------------
	package com.ravi.default_method;
	
	interface A
	{
	   default void m1()
	   {
	       System.out.println("default method of interface A");
	   }
	}
	class B
	{
	    public void m1()
	    {
	        System.out.println("Concrete method of class B");
	    }
	}
	
	class C extends B implements A
	{
	   
	}
	public class Priority
	{
	    public static void main(String[] args)
	    {
	        C c1 = new C();
	        c1.m1();
	    }
	
	}
	-------------------------------------------------------------
	Can we achieve multiple inheritance using default method :
	----------------------------------------------------------
	Multiple inheritance is possible in java by using default method inside an interface, here we 
	need to use super keyword to differenciate the super interface methods.
	Before java 1.8, we have abstract method inside an interface but now we can write method 
	body(default method) so, to execute the default method inside an interface we need to take 
	super keyword with interface name(Alpha.super.m1()).
	
	
	package com.ravi.default_method;
	
	interface Alpha
	{
	    default void m1()
	    {
	        System.out.println("m1 method of Alpha interface ");
	    }
	}
	interface Beta
	{
	    default void m1()
	    {
	        System.out.println("m1 method of Beta interface ");
	    }
	}
	class Foo implements Alpha, Beta
	{    
	    @Override
	    public void m1()
	    {
	      Alpha.super.m1();
	      Beta.super.m1();
	      System.out.println("MI is possible using default method");        
	    }    
	}
	public class MultipleInheritance {
	
	    public static void main(String[] args)
	    {
	        new Foo().m1();
	    }
	
	}
	-------------------------------------------------------------
	package com.ravi.default_method;
	
	interface Hello
	{
	    int x = 100;
	}
	abstract class Test
	{
	    int x = 200;
	}
	class MyClass extends Test implements Hello
	{
	   int x = 300; //Variable Hiding to solve ambiguity issue
	   public void show()
	   {
	     System.out.println(x);  
	   }
	}
	
	public class VariableHiding {
	
	    public static void main(String[] args)
	    {
	        new MyClass().show();
	
	    }
	
	}
	-------------------------------------------------------------
	What is static method of an interface :
	----------------------------------------
	We can write static method (method with body) inside an interface from java 8 version.
	
	Example :
	---------
	public interface Calculator
	{
	   static double getCube(int num) //java 8 [AM is public]
	   {
	   }
	}
	
	A static method must be marked with the static keyword and contains method body.
	A static method without any access modifier is assumed to be public.
	A static method cannot be marked as abstract OR final.
	A static method is not inherited and cannot be accessed in a class directly, It can be accessible through interface name only.
	---------------------------------------------------------------------------------------
	
	Program that describes static method of an interface is by default public so we can access from another package.
	
	Calculate.java(com.ravi.interface_static_method)
	package com.ravi.interface_static_method;
	
	public interface Calculate
	{
	  static double getCube(int num)
	  {
	      return (num*num*num);
	  }
	 
	  static double getSquare(int num)
	  {
	      return (num*num);
	  }
	 
	}
	
	package com.ravi.priority;
	
	import com.ravi.interface_static_method.Calculate;
	
	public class ELC //This class is in another package.
	{
	    public static void main(String[] args)
	    {
	        double result = Calculate.getCube(8);
	        System.out.println("Cube of 8 is :"+result);
	       
	        result = Calculate.getSquare(12);
	        System.out.println("Square of 12 is :"+result);
	    }
	}
	-------------------------------------------------------------
	From java 8 version It is also possible to write main method
	inside an interface and it will be executed.
	
	package com.ravi.interface_static_method;
	
	public interface Callable
	{
	  public static void main(String[] args)
	  {
	    System.out.println("Main method inside interface");
	  }
	}
	-------------------------------------------------------------
	Program that describes interface static methods are available to interafce only.
	
	package com.ravi.interface_static_method;
	
	interface Printable
	{
	    static void m1()
	    {
	        System.out.println("M1 static Method");
	    }
	}
	public class ScopeOfStaticMethod implements Printable
	{
	    public static void main(String[] args)
	    {
	        Printable.m1();
	        //ScopeOfStaticMethod.m1();        
	        //new ScopeOfStaticMethod().m1();
	    }
	
	}
	------------------------------------------------------------
	Interface Static Method:
	------------------------
	   a) Accessible using the interface name.
	   b) Cannot be hidden by implementing classes.(Not Available)
	   c) Can be called using the interface name only.
	
	Class Static Method:
	--------------------
	   a) Accessible using the class name.
	   b) Can be hidden (not overridden) in subclasses by redeclaring a static method with the same signature and compaitable return type.
	   c) Can be called using the super class, sub class name as well as sub class object.
	------------------------------------------------------------------------------------
	Introduction to Functional Programming ?
	----------------------------------------
	From JDK 8 onwards, Java also concentrated on function/method and introduced Functional Programming.
	
	It is mainly used to write concise coding so the length of the method will be reduced.
	
	What is a Functional interface in java ?
	----------------------------------------
	If an interface contains exactly one abstract method then
	that interface is known as Functional interafce.
	
	Example :
	----------
	public interface Drawable
	{
	  void draw();  //SAM [Single abstract method]
	}
	
	
	It may contain 'n' number of default and static methods but It must contain only one abstract method.
	
	In order to restrict developer to take more than one abstract method, Java software people has introduced @FunctionalInterface annotation.
	
	Example :
	---------
	@FunctionalInterface
	interface Vehicle
	{
	    void run();    
	}
	-------------------------------------------------------------
	package com.ravi.default_method;
	
	@FunctionalInterface
	interface Vehicle
	{
	    void run();    
	}
	public class MultipleInheritance
	{
	    public static void main(String[] args)
	    {
	        Vehicle car = new Vehicle()
	        {        
	            @Override
	            public void run()
	            {
	                System.out.println("Car is Running");                
	            }
	        };
	       
	        Vehicle bike = new Vehicle()
	        {        
	            @Override
	            public void run()
	            {
	                System.out.println("Bike is Running");                
	            }
	        };
	       
	        car.run();  bike.run();
	    }
	
	}
	-------------------------------------------------------------
	27-12-2024
	-----------
	What is Lambda Expression in java ?
	------------------------------------
	It is a new feature introduced in java from JDK 1.8 onwards.
	It is an anonymous function i.e function without any name.
	
	In java it is used to enable Functional Programming.
	It is used to concise our code as well as we can remove boilerplate code.
	Lambda will work only with functional interface.
	If the body of the Lambda Expression contains only one statement then curly braces are optional.
	We can also remove the variables type while defining the Lambda Expression parameter.
	If the lambda expression method contains only one parameter then we can remove () symbol also.
	
	In lambda expression return keyword is optional but if we use return keyword then {} are compulsory.
	
	Independently Lamda Expression is not a statement.
	
	It requires a target variable i.e functional interface reference only.
	
	Lamda target can't be class or abstract class, it will work with functional interface only.
	-------------------------------------------------------------
	package com.ravi.lambda;
	
	interface Vehicle
	{
	    void run();  //SAM [Single Abstract Method]
	}
	
	public class LambdaDemo1 {
	
	    public static void main(String[] args)
	    {
	        Vehicle car = () -> System.out.println("Car is Running");
	        car.run();
	
	        Vehicle bike = () -> System.out.println("Bike is Running");
	        bike.run();
	       
	       
	        Vehicle bus = () -> System.out.println("Bus is Running");
	        bus.run();
	       
	    }
	
	}
	-------------------------------------------------------------
	package com.ravi.lambda;
	
	@FunctionalInterface
	interface Calculate
	{
	    void doSum(int x , int y);
	}
	
	public class LambdaDemo2
	{
	   public static void main(String[] args)
	   {
	      Calculate c1 = (c,  d)-> System.out.println("Sum is :"+(c+d));
	      c1.doSum(12, 12);
	   }
	}
	-------------------------------------------------------------
	package com.ravi.lambda;
	
	import java.util.Scanner;
	
	interface Length
	{
	    public abstract int findLength(String str);
	}
	
	public class LambdaDemo3
	{
	    public static void main(String[] args)
	    {
	        Length length = str -> str.length();
	       
	       
	        Scanner sc = new Scanner(System.in);
	        System.out.println("Please Enter your city Name :");
	        String cityName = sc.next();
	        System.out.println("Length of "+cityName+" is :"+length.findLength(cityName));
	        sc.close();
	    }
	
	}
	-------------------------------------------------------------
	The following program explains that Lambda target must be
	functional interface only.
	
	@FunctionalInterface
	interface Drawable
	{
	    void draw();
	}
	
	public class Main
	{    
	    public static void main(String[] args)
	    {
	      Drawable d1 =    ()-> System.out.println("Drawing");
	      d1.draw();
	    }
	}
	-------------------------------------------------------------
	What is type parameter<T> in java ?
	------------------------------------
	It is a technique through which we can make our application indepenedent of data type. It is represented by <T>
	
	In java we can pass Wrapper classes as well as User-defined classes to this type parameter(Only Reference type is reqd).
	
	We cannot pass any primitive type to this type parameter.
	
	package com.ravi.type_parameter;
	
	class Box<T>
	{
	    private T data;
	
	    public Box(T data) //Student data =
	    {
	        super();
	        this.data = data;
	    }
	
	    public T getData()
	    {
	        return data;
	    }    
	}
	
	public class TypeParameterDemo
	{
	    public static void main(String[] args)
	    {
	        Box<Integer> intType = new Box<Integer>(12);
	        System.out.println("Integer Type :"+intType.getData());
	       
	       
	        Box<Double> doubleType = new Box<Double>(23.89);
	        System.out.println("Double Type :"+doubleType.getData());
	       
	       
	        Box<Boolean> booleanType = new Box<Boolean>(true);
	        System.out.println("Boolean Type :"+booleanType.getData());
	       
	       
	        Box<Student> studentType = new Box<Student>(new Student(111));
	        System.out.println("Student Type :"+studentType.getData());
	    }
	
	}
	
	class Student
	{
	    private int id;
	
	    public Student(int id)
	    {
	        super();
	        this.id = id;
	    }
	
	    @Override
	    public String toString()
	    {
	        return "Student [id : " + id + "]";
	    }
	   
	}
	-------------------------------------------------------------
	28-12-2024
	-----------
	//Program by using Lambda to verify whether a number is even or
	  odd
	 
	import java.util.*;
	
	@FunctionalInterface
	interface Predictable
	{
	    boolean predict(int x);
	}
	
	public class Main
	{    
	    public static void main(String[] args)
	    {
	       Predictable p1 =  num ->
	        {
	            return num % 2 == 0;
	        };
	       
	        Scanner sc = new Scanner(System.in);
	        System.out.print("Enter a Number :");
	        int no = sc.nextInt();
	        boolean isEven = p1.predict(no);
	        System.out.println("Is "+no+ " even number "+isEven);
	    }
	}
	---------------------------------------------------------------
	Working with predefined functional interfaces :
	------------------------------------------------------
	In order to help the java programmer to write concise  java code in day to day programming java software people has provided the following predefined functional interfaces
	
	1) Predicate<T>          boolean test(T x);
	2) Consumer<T>           void accept(T x);
	3) Function<T,R>         R apply(T x);
	4) Supplier<T>           T get();
	5) BiPredicate<T,U>      boolean test(T x, U y);
	6) BiConsumer<T, U>      void accept(T x, U y);
	7) BiFunction<T,U,R>     R apply(T x, U y);
	8) UnaryOperator<T>      T apply(T x)
	9) BinaryOperator<T>     T apply(T x, T y)
	
	Note :-
	-------
	All these predefined functional interfaces are provided as a part of java.util.function sub package.
	
	Predicate<T> functional interface  :
	-------------------------------------------
	It is a predefined functional interface available in java.util.function sub package.
	
	It contains an abstract method test() which takes type parameter <T> and returns boolean value. The main purpose of this interface to test one argument boolean expression.
	
	@FunctionalInterface
	public interface Predicate<T>  
	{
	  boolean test(T x);
	}
	
	
	Note :- Here T is a "type parameter" and it can accept any type of User defined class as well as  Wrapper class like Integer, Float, Double and so on.
	
	We can't pass primitive type.
	-----------------------------------------------------------
	Programs on Predicate :
	-----------------------
	package com.ravi.predicate_demo;
	
	import java.util.Scanner;
	import java.util.function.Predicate;
	
	public class PredicateDemo1
	{
	    public static void main(String[] args)
	    {
	      //Verify whether a person is eligible for vote or not
	       
	      Predicate<Integer> p1 =  age ->
	      {
	          return age >=18;  
	      };
	         
	
	      Scanner sc = new Scanner(System.in);
	      System.out.print("Enter your Age :");
	      int age = sc.nextInt();
	     
	      boolean isEligible =  p1.test(age);
	     
	      if(isEligible)
	      {
	          System.out.println("You are eligible for Voting");
	      }
	      else
	      {
	          System.out.println("You are not eligible for Voting");
	         
	      }
	      sc.close();
	
	    }
	
	}
	--------------------------------------------------------------
	package com.ravi.predicate_demo;
	
	import java.util.Scanner;
	import java.util.function.Predicate;
	
	public class PredicateDemo2
	{
	    public static void main(String[] args)
	    {
	      //Verify whether my name is Ravi or not
	       
	      Predicate<String> p2 = str -> str.equalsIgnoreCase("Ravi");
	     
	      Scanner sc = new Scanner(System.in);
	      System.out.print("Enter your Name :");    
	      String name = sc.next();        
	
	      System.out.println("Are you Ravi :? "+p2.test(name));
	      sc.close();
	     
	     
	     
	    }
	
	}
	---------------------------------------------------------------
	package com.ravi.predicate_demo;
	
	import java.util.Scanner;
	import java.util.function.Predicate;
	
	public class PredicateDemo3 {
	
	    public static void main(String[] args)
	    {
	        //Verify whether my name starts with Character 'A' or not
	       
	        Predicate<String> p3 = str -> str.startsWith("A");
	       
	        Scanner sc = new Scanner(System.in);
	        System.out.print("Enter your Name :");    
	        String name = sc.next();    
	       
	        System.out.println("The name "+name+" starts with character A ?:"+p3.test(name));
	        sc.close();
	
	    }
	
	}
	---------------------------------------------------------------
	Consumer<T> functional interface :
	-----------------------------------------
	It is a predefined functional interface available in java.util.function sub package.
	
	It contains an abstract method accept() which takes T type parameter and returns nothing (void). It is used to accept the parameter value or consume the value.
	
	@FunctionalInterface
	public interface Consumer<T>
	{
	    void accept(T x);
	}
	---------------------------------------------------------------
	package com.ravi.consumer_demo;
	
	import java.util.function.Consumer;
	
	public class ConsumerDemo {
	
	    public static void main(String[] args) {
	        Consumer<Integer> c1 = num -> System.out.println(num);
	        c1.accept(12);
	
	        Consumer<String> c2 = str -> System.out.println(str);
	        c2.accept("Java");
	       
	       
	        Consumer<Employee> c3 = emp -> System.out.println(emp);
	        c3.accept(new Employee(111, "Scott"));
	    }
	
	}
	
	class Employee
	{
	    private int empId;
	    private String empName;
	
	    public Employee(int empId, String empName)
	    {
	        super();
	        this.empId = empId;
	        this.empName = empName;
	    }
	
	    @Override
	    public String toString()
	    {
	        return "Employee [empId=" + empId + ", empName=" + empName + "]";
	    }
	
	}
	---------------------------------------------------------------
	Function<T,R> functional interface :
	-----------------------------------------
	Type Parameters:
	T - the type of the input to the function.
	R - the type of the result of the function.
	
	It is a predefined functional interface available in java.util.function sub package.
	
	It provides an abstract method apply that accepts one argument(T) and produces a result(R).
	
	Note :- The type of T(input) and the type of R(Result) both will be decided by the user.
	
	@FunctionalInterface
	public interface Function<T,R>
	{
	   public abstract R apply(T x);        
	}
	--------------------------------------------------------------
	package com.ravi.function;
	
	import java.util.function.Function;
	
	public class FunctionDemo1 {
	
	    public static void main(String[] args)
	    {
	      //Find the cube of a number
	      Function<Integer,Integer> fn1 = num -> num*num*num;
	      System.out.println(fn1.apply(5));
	    }
	
	}
	--------------------------------------------------------------
	package com.ravi.function;
	
	import java.util.Scanner;
	import java.util.function.Function;
	
	public class FunctionDemo2 {
	
	    public static void main(String[] args)
	    {
	        // I want to find the length of the given city
	       
	        Function<String,Integer> fn2 = city -> city.length();
	       
	        Scanner sc = new Scanner(System.in);
	        System.out.print("Enter your City Name :");
	        String city = sc.next();
	       
	        System.out.println("The length of "+city+" is :"+fn2.apply(city));
	
	           
	        sc.close();
	    }
	
	}
	---------------------------------------------------------------
	30-12-2024
	----------
	package com.ravi.interface_demo;
	
	import java.sql.SQLSyntaxErrorException;
	import java.util.Scanner;
	import java.util.function.Function;
	
	public class FunctionDemo3 {
	
	    public static void main(String[] args)
	    {
	        //Verify whether my name starts with "Ravi" or not
	        Function<String,Boolean> fn3 = str -> str.equals("Ravi");
	
	        Scanner sc = new Scanner(System.in);
	        System.out.print("Enter your Name :");    
	        String name = sc.next();
	       
	        Boolean isRavi = fn3.apply(name);
	       
	        if(isRavi)
	        {
	            System.out.println("Yes He is Ravi");
	        }
	        else
	        {
	            System.err.println("No He is not Ravi");
	        }
	        sc.close();
	       
	    }
	
	}                    
	---------------------------------------------------------------
	Supplier<T> prdefined functional interface :
	--------------------------------------------
	It is a predefined functional interface available in java.util.function sub package.
	
	It provides an abstract method get() which does not take any argument but produces/supply/return a value of type T.
	
	@FunctionalInterface
	public interface Supplier<T>
	{
	   T get();
	}
	--------------------------------------------------------------
	//Psssing String to the Supplier
	
	package com.ravi.interface_demo;
	
	import java.util.function.Supplier;
	
	public class SupplierDemo1
	{
	    public static void main(String[] args)
	    {
	        Supplier<String> s1 = () -> 12 + 90+ " " + 34 ;        
	        String data = s1.get();
	        System.out.println(data);
	    }
	
	}
	---------------------------------------------------------------
	//Passing an Employee to the Supplier
	package com.ravi.interface_demo;
	
	import java.util.Objects;
	import java.util.function.Supplier;
	
	class Employee
	{
	    private Integer employeeId;
	    private String employeeName;
	   
	    public Employee(Integer employeeId, String employeeName)
	    {
	        super();
	        this.employeeId = employeeId;
	        this.employeeName = employeeName;
	    }
	
	    @Override
	    public String toString()
	    {
	        return "Employee [employeeId=" + employeeId + ", employeeName=" + employeeName + "]";
	    }
	
	    public Integer getEmployeeId() {
	        return employeeId;
	    }
	
	    public void setEmployeeId(Integer employeeId) {
	        this.employeeId = employeeId;
	    }
	
	    public String getEmployeeName() {
	        return employeeName;
	    }
	
	    public void setEmployeeName(String employeeName) {
	        this.employeeName = employeeName;
	    }
	
	    @Override
	    public int hashCode()
	    {
	        return Objects.hash(employeeId, employeeName);
	    }
	
	    @Override
	    public boolean equals(Object obj) {
	        if (this == obj)
	            return true;
	        if (obj == null)
	            return false;
	        if (getClass() != obj.getClass())
	            return false;
	        Employee other = (Employee) obj;
	        return Objects.equals(employeeId, other.employeeId) && Objects.equals(employeeName, other.employeeName);
	    }
	}

	public class SupplierDemo2
	{
	    public static void main(String[] args)
	    {
	        Supplier<Employee> s2 = () ->
	        {
	            Employee e1 = new Employee(111, "Scott");
	            return e1;
	        };
	       
	        System.out.println(s2.get());
	
	    }
	
	}
